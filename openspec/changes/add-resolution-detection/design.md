# Design: Resolution Detection for Video Stream Endpoints

## Context
视频流端点需要支持分辨率识别，以便用户能够区分和管理不同码率的视频流。分辨率分为三个等级：普清（SD）、高清（HD）、超清（UHD/4K）。

## Goals / Non-Goals

### Goals
- 自动从流路径或 URL 中识别分辨率标识
- 支持实际视频流分辨率检测（通过访问视频流获取真实分辨率）
- 支持三个分辨率等级：普清、高清、超清
- 在创建和更新端点时自动设置分辨率
- 提供测试播放功能，允许用户手动触发分辨率检测
- 提供数据迁移脚本，为现有端点填充分辨率
- 前端支持显示和按分辨率筛选
- 前端支持测试播放按钮，点击后播放视频流并自动识别分辨率

### Non-Goals
- 不实现分辨率转换功能
- 不实现分辨率质量评估（仅识别分辨率值）

## Decisions

### Decision: 分辨率识别方式
- **选择**: 从流路径（`full_path`）中识别分辨率标识
- **理由**:
  - 流路径通常包含分辨率标识（如 `path/SD/xxx.flv`, `path/HD/xxx.flv`）
  - 无需实际访问视频流，性能更好
  - 实现简单，维护成本低
- **识别规则**:
  - 路径包含 "SD" 或 "sd" → 普清
  - 路径包含 "HD" 或 "hd" → 高清
  - 路径包含 "UHD"、"uhd"、"4K" 或 "4k" → 超清
  - 默认值：如果无法识别，设置为 "普清" 或 NULL（可配置）

### Decision: 数据库字段类型
- **选择**: `VARCHAR(20)` 存储分辨率文本（"普清"、"高清"、"超清"）
- **理由**:
  - 便于前端显示和筛选
  - 支持未来扩展（如 "2K"、"8K" 等）
  - 避免枚举类型的迁移复杂性
- **替代方案**: ENUM 类型
  - 未选择原因：PostgreSQL ENUM 类型修改需要重建表，迁移成本高

### Decision: 默认值处理
- **选择**: 无法识别时设置为 "普清"（默认最低分辨率）
- **理由**:
  - 确保所有端点都有分辨率值
  - 普清作为默认值最安全（兼容性最好）
- **替代方案**: NULL 值
  - 未选择原因：需要前端处理 NULL 值，增加复杂度

### Decision: 分辨率识别时机
- **选择**: 在创建和更新端点时自动识别（基于路径），并提供手动测试播放检测接口
- **理由**:
  - 确保数据一致性
  - 避免手动设置错误
  - 批量生成时自动识别所有端点
  - 提供实际流检测作为补充验证手段
- **实现位置**:
  - Repository 层：在插入/更新前调用路径识别函数
  - Service 层：提供测试播放检测接口（实际访问视频流）
  - Handler 层：提供测试播放 API 端点

### Decision: 实际视频流分辨率检测
- **选择**: 使用 [lal](https://github.com/q191201771/lal) Go 库检测视频流分辨率
- **理由**:
  - lal 是纯 Go 实现的音视频直播流媒体库，无需外部依赖
  - 支持多种协议（RTMP、RTSP、HLS、HTTP-FLV/TS、WebSocket-FLV 等）
  - 可以作为 Go 包直接集成，无需调用外部命令
  - 性能好，资源占用低
  - 支持超时控制和错误处理
  - 可以解析 H264/H265 视频流，获取实际分辨率信息
- **实现方式**:
  - 使用 lal 的客户端功能拉取视频流
  - 解析视频流中的 SPS (Sequence Parameter Set) 获取分辨率信息
  - 设置超时（如 10 秒），超时则返回错误
  - 根据分辨率值判断等级：
    - 宽度 ≤ 720px → 普清
    - 720px < 宽度 ≤ 1080px → 高清
    - 宽度 > 1080px → 超清（包括 1920px 及更高）
- **依赖**: 
  - 添加 `github.com/q191201771/lal` 到 `go.mod`
  - 使用 lal 的 `pkg/avc` 或 `pkg/hevc` 包解析视频流
- **替代方案**: 
  - FFmpeg（通过 os/exec 调用）
    - 未选择原因：需要外部依赖，部署复杂，性能开销大
  - 其他 Go 视频处理库
    - 未选择原因：lal 专门针对直播流，功能更匹配

## Risks / Trade-offs

### Risks
1. **识别准确性**: 如果流路径命名不规范，可能识别错误
   - **缓解**: 提供手动更新接口，允许用户修正
   - **缓解**: 记录识别规则，便于调试和优化

2. **现有数据迁移**: 需要为大量现有端点识别分辨率
   - **缓解**: 使用批量更新脚本，支持分批处理
   - **缓解**: 提供默认值，确保迁移不会失败

3. **性能影响**: 每次创建/更新都需要识别
   - **缓解**: 识别逻辑简单（字符串匹配），性能影响可忽略

### Trade-offs
- **简单性 vs 准确性**: 
  - 路径识别：简单快速，但可能不准确
  - 流检测：准确但需要实际访问视频流，性能开销大
  - **方案**: 结合两者，默认使用路径识别，提供流检测作为验证手段

## Migration Plan

### 步骤
1. **数据库迁移**:
   - 添加 `resolution VARCHAR(20)` 列，允许 NULL
   - 为现有数据设置默认值 "普清"
   - 创建索引（如需要按分辨率筛选）

2. **代码更新**:
   - 更新模型定义
   - 实现分辨率识别函数
   - 更新 Repository 和 Service 层
   - 更新 API 响应

3. **数据迁移**:
   - 运行批量识别脚本，为现有端点识别并更新分辨率
   - 验证识别准确性

4. **前端更新**:
   - 更新类型定义
   - 显示分辨率列
   - 添加分辨率筛选器

5. **测试验证**:
   - 单元测试分辨率识别逻辑
   - 集成测试创建/更新端点
   - 验证现有数据迁移结果

### 回滚计划
- 如果识别逻辑有问题，可以：
  1. 保留 `resolution` 字段但允许 NULL
  2. 提供手动更新接口
  3. 后续优化识别规则

## Open Questions
- [x] 是否需要支持自定义分辨率标识规则（配置化）？ → 暂不支持，使用固定规则
- [x] 是否需要记录识别来源（自动识别 vs 手动设置）？ → 暂不支持，后续可扩展
- [x] 是否需要支持分辨率优先级（如同时包含 HD 和 UHD 时选择哪个）？ → 已实现，按 UHD > HD > SD 优先级
- [ ] 测试播放是否需要缓存结果（避免重复检测）？
- [ ] 测试播放失败时的重试策略？

