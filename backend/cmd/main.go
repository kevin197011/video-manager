// Copyright (c) 2025 kk
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	ginSwagger "github.com/swaggo/gin-swagger"
	swaggerFiles "github.com/swaggo/files"
	"github.com/video-manager/backend/internal/handlers"
	"github.com/video-manager/backend/internal/services"
	"github.com/video-manager/backend/pkg/database"
	"github.com/video-manager/backend/pkg/logger"
	"github.com/video-manager/backend/pkg/middleware"
	"github.com/video-manager/backend/docs" // docs is generated by Swag CLI
)

// @title Video Manager API
// @version 1.0
// @description Video Manager API Documentation
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @BasePath /

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	// Initialize logger first
	logger.Init()

	// Load environment variables
	if err := godotenv.Load(); err != nil {
		logger.Debug("No .env file found, using environment variables")
	}

	logger.Info("Starting Video Manager Backend",
		"version", "1.0.0",
		"log_level", os.Getenv("LOG_LEVEL"),
		"log_format", os.Getenv("LOG_FORMAT"),
	)

	// Initialize database
	if err := database.Init(); err != nil {
		logger.Error("Failed to initialize database", "error", err)
		os.Exit(1)
	}
	defer database.Close()
	logger.Info("Database connection established")

	// Run migrations
	if err := runMigrations(); err != nil {
		logger.Error("Failed to run migrations", "error", err)
		os.Exit(1)
	}

	// Initialize admin user
	if err := initAdminUser(); err != nil {
		logger.Error("Failed to initialize admin user", "error", err)
		os.Exit(1)
	}

	// Initialize Swagger documentation
	if err := initSwaggerDocs(); err != nil {
		logger.Warn("Failed to initialize Swagger docs", "error", err)
		logger.Info("Swagger documentation will not be available. You can manually run 'swag init' in the backend directory.")
	}

	// Dynamically configure Swagger host
	// If SWAGGER_HOST environment variable is set, use it
	// Otherwise, set to empty string to let Swagger UI auto-detect from current page
	swaggerHost := os.Getenv("SWAGGER_HOST")
	if swaggerHost != "" {
		docs.SwaggerInfo.Host = swaggerHost
		logger.Info("Swagger host configured from environment", "host", swaggerHost)
	} else {
		// Empty host means Swagger UI will use window.location.host (current page's host)
		docs.SwaggerInfo.Host = ""
		logger.Info("Swagger host set to auto-detect from current page")
	}

	// Setup router
	r := gin.Default()

	// Add logging middleware
	r.Use(middleware.LoggerMiddleware())

	// CORS middleware
	r.Use(func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	})

	// Initialize handlers
	authHandler := handlers.NewAuthHandler()
	providerHandler := handlers.NewCDNProviderHandler()
	lineHandler := handlers.NewCDNLineHandler()
	statsHandler := handlers.NewStatsHandler()
	domainHandler := handlers.NewDomainHandler()
	streamHandler := handlers.NewStreamHandler()
	streamPathHandler := handlers.NewStreamPathHandler()
	endpointHandler := handlers.NewVideoStreamEndpointHandler()

	// Public routes (no authentication required)
	api := r.Group("/api")
	{
		// Auth routes (public)
		auth := api.Group("/auth")
		{
			auth.POST("/login", authHandler.Login)
		}
	}

	// Protected routes (authentication required)
	protected := api.Group("")
	protected.Use(middleware.AuthMiddleware())
	{
		// Auth routes (protected)
		protected.POST("/auth/change-password", authHandler.ChangePassword)
		protected.GET("/auth/me", authHandler.GetCurrentUser)
		protected.GET("/auth/token-info", authHandler.GetTokenInfo)
		protected.GET("/auth/tokens", authHandler.GetTokens)
		protected.POST("/auth/tokens", authHandler.CreateToken)
		protected.DELETE("/auth/tokens/:id", authHandler.DeleteToken)

		// Stats route
		protected.GET("/stats", statsHandler.GetStats)

		// CDN Provider routes
		providers := protected.Group("/cdn-providers")
		{
			providers.GET("", providerHandler.GetAll)
			providers.GET("/:id", providerHandler.GetByID)
			providers.POST("", providerHandler.Create)
			providers.PUT("/:id", providerHandler.Update)
			providers.DELETE("/:id", providerHandler.Delete)
			providers.GET("/:id/lines", providerHandler.GetLinesByProvider) // Get lines by provider
		}

		// CDN Line routes
		lines := protected.Group("/cdn-lines")
		{
			lines.GET("", lineHandler.GetAll)
			lines.GET("/:id", lineHandler.GetByID)
			lines.POST("", lineHandler.Create)
			lines.PUT("/:id", lineHandler.Update)
			lines.DELETE("/:id", lineHandler.Delete)
		}

		// Domain routes
		domains := protected.Group("/domains")
		{
			domains.GET("", domainHandler.GetAll)
			domains.GET("/:id", domainHandler.GetByID)
			domains.POST("", domainHandler.Create)
			domains.PUT("/:id", domainHandler.Update)
			domains.DELETE("/:id", domainHandler.Delete)
		}

		// Stream routes (视频流区域)
		streams := protected.Group("/stream-regions")
		{
			streams.GET("", streamHandler.GetAll)
			streams.GET("/:id", streamHandler.GetByID)
			streams.POST("", streamHandler.Create)
			streams.PUT("/:id", streamHandler.Update)
			streams.DELETE("/:id", streamHandler.Delete)
		}

		// Stream Path routes
		streamPaths := protected.Group("/stream-paths")
		{
			streamPaths.GET("", streamPathHandler.GetAll)
			streamPaths.GET("/:id", streamPathHandler.GetByID)
			streamPaths.POST("", streamPathHandler.Create)
			streamPaths.PUT("/:id", streamPathHandler.Update)
			streamPaths.DELETE("/:id", streamPathHandler.Delete)
		}

		// Video Stream Endpoint routes
		endpoints := protected.Group("/video-stream-endpoints")
		{
			endpoints.GET("", endpointHandler.GetAll)
			endpoints.GET("/:id", endpointHandler.GetByID)
			endpoints.POST("/generate", endpointHandler.GenerateAll)
			endpoints.PATCH("/:id/status", endpointHandler.UpdateStatus)
		}
	}

	// Health check
	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "ok"})
	})

	// Swagger documentation
	// Try to enable Swagger if docs directory exists
	docsDir := "./docs"
	if _, err := os.Stat(docsDir); os.IsNotExist(err) {
		// Try parent directory (for Docker container)
		if _, err := os.Stat("../docs"); err == nil {
			docsDir = "../docs"
		}
	}

	// Check if swagger.json exists
	swaggerJSON := filepath.Join(docsDir, "swagger.json")

	// Handle /swagger redirect (without trailing slash) to /swagger/index.html
	r.GET("/swagger", func(c *gin.Context) {
		c.Redirect(302, "/swagger/index.html")
	})

	if _, err := os.Stat(swaggerJSON); err == nil {
		// Docs directory and swagger.json exist, enable Swagger
		logger.Info("Swagger documentation enabled", "path", swaggerJSON)
		// Register Swagger handler (this handles /swagger/*any including /swagger/index.html and /swagger/)
		// If SWAGGER_HOST is not set, Swagger UI will automatically use the current page's host
		r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	} else {
		// Docs not generated yet, provide a helpful message
		logger.Warn("Swagger documentation not found", "path", swaggerJSON)
		// Handle all /swagger/* paths
		r.GET("/swagger/*any", func(c *gin.Context) {
			path := c.Param("any")
			if path == "/index.html" || path == "" || path == "/" {
				c.JSON(200, gin.H{
					"error":   "Swagger documentation not generated",
					"message": "Swagger docs will be auto-generated on next startup if swag is installed",
					"instructions": []string{
						"1. Install swag: go install github.com/swaggo/swag/cmd/swag@latest",
						"2. Restart the backend server (swag init will run automatically)",
						"3. Or manually run: cd backend && swag init",
					},
					"note": "The initSwaggerDocs function runs on startup. Check backend logs for details.",
				})
			} else {
				c.JSON(404, gin.H{"error": "Not found"})
			}
		})
	}

	// Start server
	port := os.Getenv("API_PORT")
	if port == "" {
		port = "8080"
	}

	logger.Info("Server starting", "port", port, "host", "0.0.0.0")
	if err := r.Run(":" + port); err != nil {
		logger.Error("Failed to start server", "error", err, "port", port)
		os.Exit(1)
	}
}

func runMigrations() error {
	ctx := context.Background()

	// Use existing database connection
	if database.DB == nil {
		return fmt.Errorf("database connection not initialized")
	}

	// Determine migrations directory
	migrationsDir := "./migrations"
	if os.Getenv("MIGRATIONS_DIR") != "" {
		migrationsDir = os.Getenv("MIGRATIONS_DIR")
	} else {
		// Try to find migrations relative to the executable or current working directory
		if _, err := os.Stat("./migrations"); os.IsNotExist(err) {
			// Try parent directory (for Docker container where cmd/ is the working dir)
			if _, err := os.Stat("../migrations"); err == nil {
				migrationsDir = "../migrations"
			}
		}
	}

	// Read migration files (both .up.sql and .sql files)
	upFiles, err := filepath.Glob(filepath.Join(migrationsDir, "*.up.sql"))
	if err != nil {
		return fmt.Errorf("failed to read migration files: %w", err)
	}

	// Also include .sql files that don't have .up.sql suffix (like test data)
	sqlFiles, err := filepath.Glob(filepath.Join(migrationsDir, "*.sql"))
	if err != nil {
		return fmt.Errorf("failed to read SQL files: %w", err)
	}

	// Combine and deduplicate files
	filesMap := make(map[string]bool)
	var files []string
	for _, file := range upFiles {
		filesMap[file] = true
		files = append(files, file)
	}
	for _, file := range sqlFiles {
		// Skip .down.sql files and files already in upFiles
		base := filepath.Base(file)
		isDownFile := strings.HasSuffix(base, ".down.sql")
		if !isDownFile && !filesMap[file] {
			// Check if it's a numbered migration file (e.g., 000007_insert_test_data.sql)
			if len(base) >= 6 && base[0] >= '0' && base[0] <= '9' {
				files = append(files, file)
			}
		}
	}

	if len(files) == 0 {
		logger.Info("No migration files found")
		return nil
	}

	// Create migrations table if not exists
	_, err = database.DB.Exec(ctx, `
		CREATE TABLE IF NOT EXISTS schema_migrations (
			version INTEGER PRIMARY KEY,
			applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
		)
	`)
	if err != nil {
		return fmt.Errorf("failed to create migrations table: %w", err)
	}

	// Get applied migrations
	rows, err := database.DB.Query(ctx, "SELECT version FROM schema_migrations ORDER BY version")
	if err != nil {
		return fmt.Errorf("failed to query applied migrations: %w", err)
	}
	defer rows.Close()

	applied := make(map[int]bool)
	for rows.Next() {
		var version int
		if err := rows.Scan(&version); err != nil {
			return fmt.Errorf("failed to scan migration version: %w", err)
		}
		applied[version] = true
	}

	// Apply migrations
	for _, file := range files {
		// Extract version number from filename (e.g., 000001_create_cdn_providers.up.sql -> 1)
		var version int
		_, err := fmt.Sscanf(filepath.Base(file), "%d_", &version)
		if err != nil {
			logger.Warn("Skipping file with invalid name format", "file", file)
			continue
		}

		if applied[version] {
			logger.Debug("Migration already applied, skipping", "version", version, "file", filepath.Base(file))
			continue
		}

		logger.Info("Applying migration", "version", version, "file", filepath.Base(file))
		sql, err := os.ReadFile(file)
		if err != nil {
			return fmt.Errorf("failed to read migration file %s: %w", file, err)
		}

		tx, err := database.DB.Begin(ctx)
		if err != nil {
			return fmt.Errorf("failed to begin transaction: %w", err)
		}

		if _, err := tx.Exec(ctx, string(sql)); err != nil {
			tx.Rollback(ctx)
			return fmt.Errorf("failed to execute migration %d: %w", version, err)
		}

		if _, err := tx.Exec(ctx, "INSERT INTO schema_migrations (version) VALUES ($1)", version); err != nil {
			tx.Rollback(ctx)
			return fmt.Errorf("failed to record migration %d: %w", version, err)
		}

		if err := tx.Commit(ctx); err != nil {
			return fmt.Errorf("failed to commit migration %d: %w", version, err)
		}

		logger.Info("Migration applied successfully", "version", version, "file", filepath.Base(file))
	}

	logger.Info("All migrations applied successfully", "total", len(files))
	return nil
}

func initAdminUser() error {
	ctx := context.Background()
	authService := services.NewAuthService()

	// Get admin credentials from environment variables
	adminUsername := os.Getenv("ADMIN_USERNAME")
	if adminUsername == "" {
		adminUsername = "admin"
	}

	adminPassword := os.Getenv("ADMIN_PASSWORD")
	if adminPassword == "" {
		adminPassword = "admin123"
	}

	// Initialize admin user
	if err := authService.InitAdminUser(ctx, adminUsername, adminPassword); err != nil {
		return fmt.Errorf("failed to initialize admin user: %w", err)
	}

	logger.Info("Admin user initialized", "username", adminUsername)
	return nil
}

func initSwaggerDocs() error {
	// Check if swag command is available
	swagPath, err := exec.LookPath("swag")
	if err != nil {
		return fmt.Errorf("swag command not found: %w. Install it with: go install github.com/swaggo/swag/cmd/swag@latest", err)
	}

	// Determine backend directory
	backendDir := "."
	if os.Getenv("BACKEND_DIR") != "" {
		backendDir = os.Getenv("BACKEND_DIR")
	} else {
		// Try to find backend directory
		if _, err := os.Stat("./cmd"); os.IsNotExist(err) {
			// Try parent directory
			if _, err := os.Stat("../cmd"); err == nil {
				backendDir = ".."
			}
		}
	}

	// Check if swagger.json exists and is recent (within last hour)
	docsDir := filepath.Join(backendDir, "docs")
	swaggerJSON := filepath.Join(docsDir, "swagger.json")

	needsRegeneration := true
	if info, err := os.Stat(swaggerJSON); err == nil {
		// Check if swagger.json is recent (modified within last hour)
		if time.Since(info.ModTime()) < time.Hour {
			needsRegeneration = false
			logger.Debug("Swagger docs already exist and are recent, skipping regeneration", "path", swaggerJSON)
		}
	}

	if !needsRegeneration {
		return nil
	}

	logger.Info("Generating Swagger documentation",
		"swag_path", swagPath,
		"backend_dir", backendDir,
		"docs_dir", docsDir,
	)

	// Create docs directory if it doesn't exist
	if err := os.MkdirAll(docsDir, 0755); err != nil {
		return fmt.Errorf("failed to create docs directory: %w", err)
	}

	// Run swag init with proper arguments
	// -g specifies the main.go file location
	// -o specifies the output directory
	mainGoPath := filepath.Join(backendDir, "cmd", "main.go")
	cmd := exec.Command(swagPath, "init", "-g", mainGoPath, "-o", docsDir)
	cmd.Dir = backendDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to run swag init: %w", err)
	}

	// Verify that swagger.json was created
	if _, err := os.Stat(swaggerJSON); err != nil {
		return fmt.Errorf("swagger.json was not created after running swag init: %w", err)
	}

	logger.Info("Swagger documentation generated successfully", "path", swaggerJSON)
	return nil
}
